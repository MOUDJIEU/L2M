
############################################################ libraries ################################################################
library(MASS)
library(nlme)
library(flexmix)
library(mvtnorm)
library(purrr)
library(data.table)
library(flexmix)
library(lme4)
library(mvtnorm)
library(mclust)
########################################################################################################################################


############################################################# Estimation functions ####################################################

################################################################### Data preparation function
prepa_List = function(form,Dt, grping.Fact, rd.Fact)
{
  ### Index of measurement per individuals
  Sp <- Dt[,which(colnames(Dt)==grping.Fact)]
  S <- length(unique(Sp))
  ind.Sp <- list()
  for(s in 1:S)
  {
    ind.Sp[[s]] <- which(Sp==s)
  }
  ### List of reponses
  lst.Y <- list()
  Y <- Dt[,1]
  for(s in 1:S)
  {
    lst.Y[[s]] <- Y[ind.Sp[[s]]]
  }
  ### List of regression coefficients
  rs1 <- lmer(form,Dt)
  X <- as.data.frame(getME(rs1,"X"))
  lst.X <- list()
  for(s in 1:S)
  {
    lst.X[[s]] <- X[ind.Sp[[s]],]
  }
  ###  List of desing matrix
  # Global desing
  Dt2 <- data.table(Dt)
  Dt2[, idMes:=.I]
  glb.Z <- list()
  for(i in 1:length(rd.Fact))
  {
    b <- rd.Fact[i]
    lst.lev <- list()
    for(s in 1:S)
    {
      lst.lev[[s]] <- as.matrix(dcast(Dt2[Dt2[[rd.Fact[length(rd.Fact)]]]==s], as.formula(paste("idMes~",paste(b))), fun.aggregate = length)[,-1])
    }
    glb.Z[[i]] <- lst.lev
  }
  # List of design per species
  lst.Z <- list()
  lst.Zt <- list()
  for(s in 1:S)
  {
    lz <- list()
    lz[[1]]  <- diag(x=1,length(ind.Sp[[s]]))
    for(i in 1:length(rd.Fact))
    {
      ll <- glb.Z[[i]]
      lz[[i+1]] <- ll[[s]]
    }
    lst.Z[[s]] <- lz
    lst.Zt[[s]] <- lapply(lz,t)
  }
  ### results
  return(list(Ys = lst.Y,Xs = lst.X, Zs = lst.Z,Zts = lst.Zt,ind.Sp=ind.Sp))
}


######################################################################### Initialization function
Init = function(Dt,init.Clst,ind.Sp,form,rd.Fact,p)
{
  ### pi initialization
  K <- length(unique(init.Clst))
  pi <- c()
  S <- length(init.Clst)
  for(k in 1:K)
  {
    pi[k] <- sum(init.Clst==k)/S
  }
  ### fixed coefficients and random effect variances initialization
  mat.Beta <- matrix(NA,ncol=K,nrow=p+1)
  mat.Var <- matrix(NA,ncol=K,nrow=length(rd.Fact)+1)
  for(k in 1:K)
  {
    u <- which(init.Clst==k)
    Dtk <- Dt[ind.Sp[[u[1]]],]
    for(i in 2:length(u))
    {
      Dtk2 <- Dt[ind.Sp[[u[i]]],]
      Dtk <- rbind(Dtk,Dtk2)
    }
    rs <- lmer(form,Dtk)
    mat.Beta[,k] <- as.numeric(getME(rs,"fixef"))
    mat.Var[,k] <- c(as.numeric(getME(rs,"sigma")),as.numeric(getME(rs,"theta")))
  }
  ### Result
  return(list(pi=pi,mat.Beta=mat.Beta,mat.Var=mat.Var))
}


############################################################################# Expectation function
Expectation = function(theta,X,Y,Z,Zt)
{
  ### parameters of the previous iteration
  mat.Var <- theta$mat.Var
  mat.Bet <- theta$mat.Bet
  pi <- theta$pi
  K <- length(pi)
  S <- length(X)
  ### list of variance matrix
  lst.Sg  <- list()
  ### Matrix of likelihood
  mat.phi <- matrix(NA,ncol=K,nrow=S)
  for(k in 1:K)
  {
    # parameters for the meta population k
    vr.k <- as.numeric(mat.Var[,k])
    beta.k <- as.matrix(mat.Bet[,k],ncol=1)
    # Variance matrix for meta population k
    lst.Sg.s <- list()
    # iteration at species level
    for(s in 1:S)
    {
      Z.s <- Z[[s]]
      Zt.s <- Zt[[s]]
      Sig.sk <- vr.k[[1]]*(Z.s[[1]]%*%Zt.s[[1]])
      for(le in 2:length(vr.k))
      {
        Sig.sk <- Sig.sk + vr.k[[le]]*(Z.s[[le]]%*%Zt.s[[le]])
      }
      lst.Sg.s[[s]] <- Sig.sk
      X.s <- as.matrix(X[[s]])
      Mu.s <- as.vector(X.s %*% beta.k)
      Y.s <- Y[[s]]
      mat.phi[s,k] <-pi[k]*mvtnorm::dmvnorm(x = Y.s, mean = Mu.s, sigma = Sig.sk)
    }
    lst.Sg[[k]] <- lst.Sg.s
  }
  ### priors matrix
  mat.flou <- t(apply(mat.phi,1,function(x){x/sum(x)}))
  ### results
  return(list(mat.flou = mat.flou, mat.phi = mat.phi,lst.mat.Var=lst.Sg))
}


########################################################################### Functions for maximization step

#################################################### Beta maximization function
Maxi_Beta <- function(Y,X,Inv.mat.var,mat.flou,ind.k)
{
  mat.beta <- matrix(NA,ncol=length(ind.k),nrow=ncol(X[[1]]))
  S <- nrow(mat.flou)
  
  for(i in 1:length(ind.k)){
    k <- ind.k[i]
    ListMaxNum <- list()
    ListMaxDen <- list()
    IVsk <- Inv.mat.var[[k]]
    w <- mat.flou[,k]
    for(s in 1:S){
      Ys <- as.matrix(Y[[s]],ncol=1)
      Xs <- as.matrix(X[[s]])
      IVs <- as.matrix(IVsk[[s]])
      ListMaxNum[[s]] <- w[s]*t(Xs)%*%IVs%*%Ys
      ListMaxDen[[s]] <- w[s]*t(Xs)%*%IVs%*%Xs
    }
    Num <- ListMaxNum[[1]]
    DeNum <- ListMaxDen[[1]]
    for(s in 2:S){
      Num <- Num + ListMaxNum[[s]]
      DeNum <- DeNum + ListMaxDen[[s]]
    }
    mat.beta[,i] <- solve(DeNum)%*%Num
  }
  return(mat.beta)
}

################################### M function for varaince maximization
M_funct = function(k,mat.flou,Inv.mat.var,Z,Zt)
{
  ### affectations
  w <- mat.flou[,k]
  nl <- length(Z[[1]])
  M <- matrix(ncol=nl,nrow=nl)
  S <- nrow(mat.flou)
  IVk <- Inv.mat.var[[k]]
  
  ### computing of matrix compoments
  for(i in 1:nl)
  {
    for(j in 1:nl)
    {
      aZ <- c()
      for(s in 1:S)
      {
        IVsk <- IVk[[s]]
        Zs <- Z[[s]]
        Zi <- Zs[[i]]
        Zj <- Zs[[j]]
        Zts <- Zt[[s]]
        Zti <- Zts[[i]]
        Ztj <- Zts[[j]]
        Aij <- IVsk%*%Zi%*%Zti%*%IVsk%*%Zj%*%Ztj
        aZ[s] <- w[s]*sum(diag(Aij))
      }
      M[i,j] <- sum(aZ)
    }
  }
  return(M)
}

###################################### R function for varainces maximization
R_funct = function(k,Y,X,Z,Zt,mat.Beta,Inv.mat.var,mat.flou)
{
  ### Affectation
  S <- length(X)
  w <- mat.flou[,k]
  nl <- length(Z[[1]])
  IVk <- Inv.mat.var[[k]]
  
  R <- c()
  for(l in 1:nl)
  {
    aR <- c()
    for(s in 1:S)
    {
      IVsk <- IVk[[s]]
      Zs <- Z[[s]]
      Zts <- Zt[[s]]
      Zi <- Zs[[l]]
      Zti <- Zts[[l]]
      Mu <- as.matrix(X[[s]])%*%mat.Beta[,k]
      A <- Y[[s]]-Mu
      aR[s] <- w[s]*(t(A)%*%IVsk%*%Zi%*%Zti%*%IVsk%*%A)
    }
    R[l] <- sum(aR)
  }
  
  return(R)
}

########################### Variance Maximization function
Maxi_Var <- function(Y,X,Z,Zt,mat.Beta,mat.flou,Inv.mat.var,ind.k)
{
  nl <- length(Z[[1]])
  mat.Var <- matrix(NA,ncol=length(ind.k),nrow=nl)
  for(i in 1:length(ind.k))
  {
    k <- ind.k[i]
    M <- M_funct(k,mat.flou,Inv.mat.var,Z,Zt)
    R <- R_funct(i,Y,X,Z,Zt,mat.Beta,Inv.mat.var,mat.flou)
    
    u <- solve(M,R)
    mat.Var[,k] <- u
  }
  return(mat.Var)
}


###########################################################################  EM Maximization function
Maximization = function(res.Exp,theta,Y,X,Z,Zt)
{
  ### recuperation of elements
  mat.flou <- res.Exp$mat.flou
  lst.mat.Var <- res.Exp$lst.mat.Var
  mat.phi <- res.Exp$mat.phi
  mat.Beta <- theta$mat.Beta
  Inv.mat.var <- list()
  for(k in 1:ncol(mat.flou))
  {
    Inv.mat.var[[k]] <- lapply(lst.mat.Var[[k]],solve)
  }
  
  ### News K and S
  u1 <- apply(mat.flou,2,sum)
  ind.k <- which(u1!=0)
  u <- u1[ind.k]
  K <- length(u)
  S <- nrow(mat.flou)
  
  ### News parameters
  pi <- u/S
  mat.Beta <- Maxi_Beta(Y,X,Inv.mat.var,mat.flou,ind.k)
  mat.Var <- Maxi_Var(Y,X,Z,Zt,mat.Beta,mat.flou,Inv.mat.var,ind.k)
  theta <- list(pi=pi,mat.Beta=mat.Beta,mat.Var=mat.Var)
  
  ### Result
  return(theta)
}

############################################################################# ICL function
icl.Mclust.MLMM <- function(res,Dt)
{
  if(class(res)=="try-error")
  {
    return(NA)
  } else 
  {
    n <- nrow(Dt)
    ## Matrix of probabilities
    u <- Dt[,ncol(Dt)]
    mat.Flou <- res$mat.flou
    z <- matrix(0,nrow=length(u),ncol=ncol(mat.Flou))
    for(kk in 1:nrow(mat.Flou))
    {
      a <- which(u==kk)
      b <- mat.Flou[kk,]
      for(kkk in 1:length(a))
      {
        z[a[kkk],] <- b
      }
    }
    ## Matrix of behaviors
    if(is.null(z)) z <- matrix(1, nrow = n, ncol = 1)
    C <- matrix(0, n, ncol(z))
    for(i in 1:n)
      C[i, which.max(z[i,])] <- 1
    ## ICL
    log.vrai <- sum(log(apply(res$mat.phi,1,sum)))
    N <- length(u)
    k <- ncol(res$theta$mat.Beta)*(nrow(res$theta$mat.Beta)+nrow(res$theta$mat.Var))
    bi <- (-2*log.vrai)+(k*log(N))
    ic <- bi - 2*sum(C * ifelse(z > 0, log(z), 0))
    return(list(BIC=bi,ICL=ic))
  }
}


################################################################################ EM function
MLMM = function(form,Dt,init.Clst,grping.Fact,rd.Fact,eps=0.01,it.max=25)
{
  
  ### Lists for computing
  rs <- prepa_List(form,Dt,grping.Fact,rd.Fact)
  X <- rs$Xs
  Y <- rs$Ys
  Z <- rs$Zs
  Zt <- rs$Zts
  ind.Sp <- rs$ind.Sp
  p <- ncol(X[[1]])-1
  
  ### Initial parameters
  theta <- Init(Dt,init.Clst,ind.Sp,form,rd.Fact,p)
  # Test initialization
  res.Exp <- Expectation(theta,X,Y,Z,Zt)
  u1 <- apply(res.Exp$mat.phi,1,sum)
  if(any(u1==0))
  {
    message("Please try a new initialization")
    return(theta)
  }
  conv <- 0
  lst.rs <- list(theta=theta,mat.flou=res.Exp$mat.flou,mat.phi=res.Exp$mat.phi,conv=conv)
  
  ### Iterations
  it <- 0
  dif.lik <- eps+1
  while((it<it.max)&&(dif.lik>eps))
  {
    ### Maximization
    theta <- Maximization(res.Exp,theta,Y,X,Z,Zt)
    res.Exp <- Expectation(theta,X,Y,Z,Zt)
    u1 <- apply(res.Exp$mat.phi,1,sum)
    if(any(u1==0))
    {
      ic <- icl.Mclust.MLMM(lst.rs,Dt)$ICL
      return(list(theta=lst.rs$theta,matflou=lst.rs$mat.flou,mat.phi=lst.rs$mat.phi,ICL=ic,conv=lst.rs$conv))
    }
    dif.lik <- abs(sum(log(apply(lst.rs$mat.phi,1,sum)))-sum(log(apply(res.Exp$mat.phi,1,sum))))
    lst.rs <- list(theta=theta,mat.flou=res.Exp$mat.flou,mat.phi=res.Exp$mat.phi,conv=conv)
    it <- it + 1
    print(paste("Iteration",it,": Likelihood diff = ",dif.lik))
  }
  
  ### results
  if(it==it.max)
  {
    conv <- 0
    lst.rs <- list(theta=theta,mat.flou=res.Exp$mat.flou,mat.phi=res.Exp$mat.phi,conv=conv)
    ic <- icl.Mclust.MLMM(lst.rs,Dt)$ICL
    return(list(theta=lst.rs$theta,matflou=lst.rs$mat.flou,mat.phi=lst.rs$mat.phi,ICL=ic,conv=lst.rs$conv))
  }else
  {
    conv <- 1
    lst.rs <- list(theta=theta,mat.flou=res.Exp$mat.flou,mat.phi=res.Exp$mat.phi,conv=conv)
    ic <- icl.Mclust.MLMM(lst.rs,Dt)$ICL
    return(list(theta=lst.rs$theta,matflou=lst.rs$mat.flou,mat.phi=lst.rs$mat.phi,ICL=ic,conv=lst.rs$conv))
  }
}
######################################################################################################################################


#################################################################### Tests ############################################################

########################################################## Initialization of classification with Mclust
Init_class = function(K,Dt, max_try=10)
{
  while(max_try>0)
  {
    res <- Mclust(Dt,G=K, verbose = FALSE)
    u <- as.vector(res$classification)
    A <- as.matrix(table(u,Dt[,ncol(Dt)]))
    Rg <- as.vector(apply(A,2,which.max))
    if(length(unique(Rg))==K) {
      message(max_try)
      return(Rg)
    }
    max_try <- max_try-1
  }
  return(1)
}


################################################################## Simulation functions
MatRep = function(x,a)
{
  return(as.matrix(rep(a,x),ncol=1))
}

DesInd = function(a)
{
  b <- list()
  b[[1]] <- c(rep(1,a[1]),rep(0,sum(a[2:length(a)])))
  for(k in 2:(length(a)-1)){
    b[[k]] <- c(rep(0,sum(a[1:(k-1)])),rep(1,a[k]),rep(0,sum(a[(k+1):length(a)])))
  }
  b[[length(a)]] <- c(rep(0,sum(a[1:(length(a)-1)])),rep(1,a[length(a)]))
  matrix(unlist(b),ncol=length(a))
}

VarCp = function(k,MatVar,z0,z1,z2)
{
  a <- (MatVar[1,k]*(z0%*%t(z0))+(MatVar[2,k]*(z1%*%t(z1)))+(MatVar[3,k]*(z2%*%t(z2))))
  return(a)
}

######################################################################### Function for simulations
SimData2 = function(np = 4,p.Repart = c(0.4,0.3,0.2,0.1),p=2,sdb=3,sdv=1,S=70){
  
  #### Repartion of individual in species with repetitions
  ni <- sample(5:15,S,replace = T)
  rpList <- list()
  for(i in 1:S)
  {
    rpList[[i]] <- sample(5:20,ni[i],replace = T)
  }
  
  ##### Design matrix
  Z0 <- lapply(sapply(rpList,sum),diag)
  Z1 <- lapply(rpList,DesInd)
  Z2 <- lapply(sapply(rpList,sum),MatRep,1)
  
  ### Parameters
  MatBeta <- matrix(rnorm((p+1)*np,sample(c(-1,1),p+1,replace = T),sdb),p+1)
  MatVar <- rbind(rep(1,np),matrix(rgamma(p*np,shape=sdv,scale=1/sdv),p))
  
  ### Creation of variance matrix
  MatSigma <- list()
  for(s in 1:S){
    MatSigma[[s]] <- lapply(1:np,VarCp,MatVar,Z0[[s]],Z1[[s]],Z2[[s]])
  }
  
  ### Simulation of explonatory variables
  X <- list()
  for(s in 1:S){
    a <- rep(1,sum(rpList[[s]]))
    X[[s]] <- cbind(a,matrix(rnorm(sum(rpList[[s]])*p,0,1),nrow=sum(rpList[[s]]),ncol=p))
  }
  
  
  ### Creation of Ys
  a <- S*p.Repart
  Groups <- sample(rep(1:np,a))
  Y <- list()
  for(s in 1:S){
    k <- Groups[[s]]
    Bet <- matrix(MatBeta[,k],ncol=1)
    Xe <- X[[s]]
    V <- MatSigma[[s]][[k]]
    Mu <- Xe%*%Bet
    Y[[s]] <- mvrnorm(mu=Mu,Sigma=V)
  }
  
  
  ### global matrix
  Yf <- Y[[1]]
  Xf <- X[[1]]
  for(s in 2:S){
    Yf <- c(Yf,Y[[s]])
    Xf <- rbind(Xf,X[[s]])
  }
  
  ### indexation
  rp <- unlist(rpList)
  indI <- rep(1,rp[1])
  for(i in 2:sum(ni)){
    indI <- c(indI,rep(i,rp[i]))
  }
  indEs <- rep(1,sum(rpList[[1]]))
  for(s in 2:S){
    indEs <- c(indEs,rep(s,sum(rpList[[s]])))
  }
  
  
  ### Data frame creation
  data <- as.data.frame((cbind(Yf,Xf[,-1],indI,indEs)))
  
  ### Results
  res<- list()
  res$Data <- data
  res$class <- Groups
  res$Beta <- MatBeta
  res$MatVar <- MatVar
  res$Ni <- ni
  return(res)
}


################################################################################### tests
Rg <- 1
while(length(Rg)==1)
{
  sd <- 3
  alpha <- 1
  Sim.Data <- SimData2(sdb = sd, sdv = alpha,S=50)
  Dt <- as.data.frame(Sim.Data$Data)
  K <- 4
  Rg <- Init_class(K,Dt)
}

### M3
form <- Yf ~ V2 + V3 + (1|indEs) + (1|indI:indEs)
Dt <- as.data.frame(Sim.Data$Data)
grping.Fact <- "indEs"
rd.Fact <- c("indI","indEs")
init.Clst <- Rg
res <- MLMM(form,Dt,init.Clst,grping.Fact,rd.Fact)

### M2
Dt <- as.data.frame(Dt)
rd.Fact <- c("indI")
form <- Yf ~ V2 + V3 + (1|indI:indEs)
res2 <- MLMM(form,Dt,init.Clst,grping.Fact,rd.Fact)

### M1
Dt <- as.data.frame(Dt)
rd.Fact <- c("indEs")
form <- Yf ~ V2 + V3 + (1|indEs)
res3 <- MLMM(form,Dt,init.Clst,grping.Fact,rd.Fact)

### M0
form <- Yf ~ V2 + V3|indEs
Dt <- as.data.frame(Sim.Data$Data)
res4 <- flexmix(form,k=K,Dt)
ICL(res4)
#######################################################################################################################################
